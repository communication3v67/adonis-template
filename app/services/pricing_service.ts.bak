import { calculatePrice, calculateCostStats, MODEL_PRICING } from '../utils/pricing_calculator.js'\nimport GmbPost from '#models/gmb_post'\n\n/**\n * Service pour gérer les calculs de prix et statistiques IA\n */\nexport class PricingService {\n  /**\n   * Calcule le prix pour un post donné\n   */\n  static calculatePostPrice(\n    model: string | null,\n    inputTokens: number | null,\n    outputTokens: number | null,\n    cachedInputTokens: number | null = null\n  ): number | null {\n    return calculatePrice(model, inputTokens, outputTokens, cachedInputTokens)\n  }\n\n  /**\n   * Met à jour le prix d'un post et le sauvegarde\n   */\n  static async updatePostPrice(post: GmbPost): Promise<boolean> {\n    const calculatedPrice = this.calculatePostPrice(\n      post.model,\n      post.input_tokens,\n      post.output_tokens\n    )\n\n    if (calculatedPrice !== null) {\n      post.price = calculatedPrice\n      await post.save()\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Calcule les statistiques de coût pour un utilisateur\n   */\n  static async getUserCostStats(userId: number) {\n    const posts = await GmbPost.query()\n      .where('user_id', userId)\n      .whereNotNull('model')\n      .whereNotNull('input_tokens')\n      .whereNotNull('output_tokens')\n      .whereNotNull('price')\n\n    return calculateCostStats(posts.map(post => ({\n      model: post.model,\n      inputTokens: post.input_tokens,\n      outputTokens: post.output_tokens,\n      price: post.price\n    })))\n  }\n\n  /**\n   * Calcule les statistiques globales de coût\n   */\n  static async getGlobalCostStats() {\n    const posts = await GmbPost.query()\n      .whereNotNull('model')\n      .whereNotNull('input_tokens')\n      .whereNotNull('output_tokens')\n      .whereNotNull('price')\n\n    return calculateCostStats(posts.map(post => ({\n      model: post.model,\n      inputTokens: post.input_tokens,\n      outputTokens: post.output_tokens,\n      price: post.price\n    })))\n  }\n\n  /**\n   * Obtient la liste des modèles supportés avec leur pricing\n   */\n  static getSupportedModels() {\n    return Object.entries(MODEL_PRICING).map(([model, pricing]) => ({\n      model,\n      ...pricing\n    }))\n  }\n\n  /**\n   * Estime le coût d'un post avant sa création\n   */\n  static estimatePostCost(\n    model: string,\n    estimatedInputTokens: number,\n    estimatedOutputTokens: number\n  ): {\n    estimatedCost: number | null\n    costBreakdown: {\n      inputCost: number\n      outputCost: number\n      model: string\n    } | null\n  } {\n    const pricing = MODEL_PRICING[model.toLowerCase().trim()]\n    \n    if (!pricing) {\n      return {\n        estimatedCost: null,\n        costBreakdown: null\n      }\n    }\n\n    const inputCost = (estimatedInputTokens * pricing.inputTokenPrice) / 1_000_000\n    const outputCost = (estimatedOutputTokens * pricing.outputTokenPrice) / 1_000_000\n    const totalCost = inputCost + outputCost\n\n    return {\n      estimatedCost: totalCost,\n      costBreakdown: {\n        inputCost,\n        outputCost,\n        model\n      }\n    }\n  }\n\n  /**\n   * Recalcule tous les prix manquants\n   */\n  static async recalculateAllPrices(): Promise<{\n    updated: number\n    errors: number\n    details: Array<{ postId: number, success: boolean, error?: string }>\n  }> {\n    const posts = await GmbPost.query()\n      .whereNotNull('model')\n      .whereNotNull('input_tokens')\n      .whereNotNull('output_tokens')\n      .where((query) => {\n        query.whereNull('price').orWhere('price', 0)\n      })\n\n    const results = {\n      updated: 0,\n      errors: 0,\n      details: [] as Array<{ postId: number, success: boolean, error?: string }>\n    }\n\n    for (const post of posts) {\n      try {\n        const success = await this.updatePostPrice(post)\n        if (success) {\n          results.updated++\n          results.details.push({ postId: post.id, success: true })\n        } else {\n          results.errors++\n          results.details.push({ \n            postId: post.id, \n            success: false, \n            error: 'Modèle non supporté' \n          })\n        }\n      } catch (error) {\n        results.errors++\n        results.details.push({ \n          postId: post.id, \n          success: false, \n          error: error.message \n        })\n      }\n    }\n\n    return results\n  }\n}\n