import { useState, useCallback } from 'react'
import { notifications } from '@mantine/notifications'
import { GmbPost } from '../types'

/**
 * Hook personnalis√© pour g√©rer l'envoi vers webhook n8n
 */
export const useWebhook = () => {
    const [sendingToN8n, setSendingToN8n] = useState(false)
    const [sendingSinglePost, setSendingSinglePost] = useState<number | null>(null)
    const [webhookResponse, setWebhookResponse] = useState<any>(null)
    const [showWebhookModal, setShowWebhookModal] = useState(false)

    // Fonction pour obtenir le token CSRF
    const getCsrfToken = useCallback(() => {
        const csrfToken = document
            .querySelector('meta[name="csrf-token"]')
            ?.getAttribute('content')
        
        if (!csrfToken) {
            throw new Error('Token CSRF manquant. Actualisez la page.')
        }
        
        return csrfToken
    }, [])

    // Envoyer tous les posts "Post √† g√©n√©rer" vers n8n
    const sendPostsToN8n = useCallback(async (postsToGenerateCount: number) => {
        if (postsToGenerateCount === 0) {
            notifications.show({
                title: 'Information',
                message: 'Aucun post "Post √† g√©n√©rer" √† envoyer',
                color: 'blue',
            })
            return
        }

        setSendingToN8n(true)
        setWebhookResponse(null)

        try {
            console.log(`üöÄ Envoi de ${postsToGenerateCount} posts GMB vers n8n`)
            console.log('üîç DEBUG: D√©but de la requ√™te fetch')
            
            const csrfToken = getCsrfToken()
            console.log('üîç DEBUG: Token CSRF obtenu:', csrfToken ? 'OK' : 'MANQUANT')
            
            const response = await fetch('/gmb-posts/send-to-n8n', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': csrfToken,
                    'Accept': 'application/json',
                },
            })

            console.log('üîç DEBUG: R√©ponse re√ßue:')
            console.log('  - Status:', response.status)
            console.log('  - StatusText:', response.statusText)
            console.log('  - OK:', response.ok)
            console.log('  - Headers:', Object.fromEntries(response.headers.entries()))

            // Toujours lire le texte de la r√©ponse d'abord
            const responseText = await response.text()
            console.log('üîç DEBUG: Texte de r√©ponse (premiers 500 chars):', responseText.substring(0, 500))
            
            if (!response.ok) {
                console.log('üö® DEBUG: R√©ponse NOT OK - Traitement de l\'erreur')
                
                // G√©rer sp√©cifiquement les erreurs 500 et autres codes d'erreur
                let errorMessage = `Erreur HTTP ${response.status}: ${response.statusText}`
                console.log('üîç DEBUG: Message d\'erreur initial:', errorMessage)
                
                // Essayer d'extraire un message d'erreur plus d√©taill√© si disponible
                try {
                    const errorData = JSON.parse(responseText)
                    console.log('üîç DEBUG: JSON d\'erreur pars√©:', errorData)
                    if (errorData.message) {
                        errorMessage = errorData.message
                    } else if (errorData.error) {
                        errorMessage = errorData.error
                    }
                } catch (parseError) {
                    console.log('üîç DEBUG: Impossible de parser le JSON d\'erreur:', parseError)
                    // Si ce n'est pas du JSON, utiliser le texte brut s'il est informatif
                    if (responseText && !responseText.trim().startsWith('<!DOCTYPE')) {
                        errorMessage = responseText.substring(0, 200) // Limiter √† 200 caract√®res
                    }
                }
                
                console.log('üîç DEBUG: Message d\'erreur final:', errorMessage)
                console.log('üö® DEBUG: LANCEMENT DE L\'EXCEPTION')
                throw new Error(errorMessage)
            }
            
            // V√©rifier si c'est du HTML (redirection)
            if (responseText.trim().startsWith('<!DOCTYPE')) {
                throw new Error("La requ√™te a √©t√© redirig√©e. Probl√®me d'authentification ou de route.")
            }

            const result = JSON.parse(responseText)
            
            setWebhookResponse(result.data || result)
            setShowWebhookModal(true)

            notifications.show({
                title: 'Succ√®s',
                message: `${postsToGenerateCount} posts GMB envoy√©s avec succ√®s vers n8n !`,
                color: 'green',
            })
        } catch (error) {
            console.log('üö® DEBUG: ENTR√âE DANS LE CATCH')
            console.error('üö® Erreur webhook compl√®te:', error)
            console.log('üîç DEBUG: Type d\'erreur:', typeof error)
            console.log('üîç DEBUG: error instanceof Error:', error instanceof Error)
            
            // Gestion d√©taill√©e des diff√©rents types d'erreurs
            let errorMessage = 'Erreur inconnue lors de l\'envoi vers n8n'
            
            if (error instanceof Error) {
                errorMessage = error.message
                console.log('üîç DEBUG: Message d\'erreur extrait:', errorMessage)
            } else if (typeof error === 'string') {
                errorMessage = error
                console.log('üîç DEBUG: Erreur string:', errorMessage)
            }
            
            // Ajouter des informations contextuelles pour certaines erreurs
            if (errorMessage.includes('fetch')) {
                errorMessage = 'Erreur de connexion au serveur. V√©rifiez votre connexion internet.'
            } else if (errorMessage.includes('404')) {
                errorMessage = 'Route non trouv√©e (404). La fonctionnalit√© d\'envoi vers n8n pourrait √™tre d√©sactiv√©e.'
            } else if (errorMessage.includes('401')) {
                errorMessage = 'Non autoris√© (401). Veuillez vous reconnecter.'
            } else if (errorMessage.includes('403')) {
                errorMessage = 'Acc√®s interdit (403). Vous n\'avez pas les permissions n√©cessaires.'
            } else if (errorMessage.includes('500')) {
                errorMessage = 'Erreur interne du serveur (500). Le webhook n8n pourrait √™tre indisponible.'
            }
            
            console.log('üîç DEBUG: Message final pour notification:', errorMessage)
            console.log('üö® DEBUG: TENTATIVE D\'AFFICHAGE DE LA NOTIFICATION')
            
            // Toujours afficher la notification d'erreur
            const notificationId = notifications.show({
                title: 'Erreur d\'envoi vers n8n',
                message: errorMessage,
                color: 'red',
                autoClose: 8000, // Garder plus longtemps pour les erreurs
            })
            
            console.log('üîç DEBUG: Notification ID:', notificationId)
            console.log('üö® DEBUG: NOTIFICATION ENVOY√âE')
            
            // Ouvrir la modale m√™me en cas d'erreur pour afficher les d√©tails
            setWebhookResponse({
                error: true,
                message: errorMessage,
                details: error instanceof Error ? error.stack : error
            })
            setShowWebhookModal(true)
        } finally {
            setSendingToN8n(false)
        }
    }, [getCsrfToken])

    // Envoyer un post individuel vers n8n
    const sendSinglePostToN8n = useCallback(async (post: GmbPost) => {
        // V√©rification c√¥t√© client
        if (post.status !== 'Post √† g√©n√©rer') {
            notifications.show({
                title: 'Action non autoris√©e',
                message: `Ce post ne peut pas √™tre envoy√©. Statut actuel: "${post.status}". Seuls les posts "Post √† g√©n√©rer" peuvent √™tre envoy√©s.`,
                color: 'orange',
            })
            return
        }

        setSendingSinglePost(post.id)
        setWebhookResponse(null)

        try {
            console.log(`üöÄ Envoi du post GMB individuel (ID: ${post.id}) vers n8n`)
            
            const csrfToken = getCsrfToken()

            const response = await fetch(`/gmb-posts/${post.id}/send-to-n8n`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': csrfToken,
                    'Accept': 'application/json',
                },
            })

            // Toujours lire le texte de la r√©ponse d'abord
            const responseText = await response.text()
            
            if (!response.ok) {
                // G√©rer sp√©cifiquement les erreurs 500 et autres codes d'erreur
                let errorMessage = `Erreur HTTP ${response.status}: ${response.statusText}`
                
                // Essayer d'extraire un message d'erreur plus d√©taill√© si disponible
                try {
                    const errorData = JSON.parse(responseText)
                    if (errorData.message) {
                        errorMessage = errorData.message
                    } else if (errorData.error) {
                        errorMessage = errorData.error
                    }
                } catch {
                    // Si ce n'est pas du JSON, utiliser le texte brut s'il est informatif
                    if (responseText && !responseText.trim().startsWith('<!DOCTYPE')) {
                        errorMessage = responseText.substring(0, 200) // Limiter √† 200 caract√®res
                    }
                }
                
                throw new Error(errorMessage)
            }
            
            if (responseText.trim().startsWith('<!DOCTYPE')) {
                throw new Error("La requ√™te a √©t√© redirig√©e. Probl√®me d'authentification ou de route.")
            }

            const result = JSON.parse(responseText)
            
            setWebhookResponse(result.data || result)
            setShowWebhookModal(true)

            notifications.show({
                title: 'Succ√®s',
                message: `Post "${post.text?.substring(0, 30)}..." envoy√© avec succ√®s vers n8n !`,
                color: 'green',
            })
        } catch (error) {
            console.log('üö® DEBUG: ENTR√âE DANS LE CATCH (POST INDIVIDUEL)')
            console.error('üö® Erreur webhook post individuel:', error)
            console.log('üîç DEBUG: Type d\'erreur:', typeof error)
            console.log('üîç DEBUG: error instanceof Error:', error instanceof Error)
            
            // Gestion d√©taill√©e des diff√©rents types d'erreurs
            let errorMessage = 'Erreur inconnue lors de l\'envoi vers n8n'
            
            if (error instanceof Error) {
                errorMessage = error.message
                console.log('üîç DEBUG: Message d\'erreur extrait:', errorMessage)
            } else if (typeof error === 'string') {
                errorMessage = error
                console.log('üîç DEBUG: Erreur string:', errorMessage)
            }
            
            // Ajouter des informations contextuelles pour certaines erreurs
            if (errorMessage.includes('fetch')) {
                errorMessage = 'Erreur de connexion au serveur. V√©rifiez votre connexion internet.'
            } else if (errorMessage.includes('404')) {
                errorMessage = 'Route non trouv√©e (404). La fonctionnalit√© d\'envoi vers n8n pourrait √™tre d√©sactiv√©e.'
            } else if (errorMessage.includes('401')) {
                errorMessage = 'Non autoris√© (401). Veuillez vous reconnecter.'
            } else if (errorMessage.includes('403')) {
                errorMessage = 'Acc√®s interdit (403). Vous n\'avez pas les permissions n√©cessaires.'
            } else if (errorMessage.includes('500')) {
                errorMessage = 'Erreur interne du serveur (500). Le webhook n8n pourrait √™tre indisponible.'
            }
            
            console.log('üîç DEBUG: Message final pour notification:', errorMessage)
            console.log('üö® DEBUG: TENTATIVE D\'AFFICHAGE DE LA NOTIFICATION (POST INDIVIDUEL)')
            
            // Toujours afficher la notification d'erreur
            const notificationId = notifications.show({
                title: 'Erreur d\'envoi du post vers n8n',
                message: errorMessage,
                color: 'red',
                autoClose: 8000, // Garder plus longtemps pour les erreurs
            })
            
            console.log('üîç DEBUG: Notification ID (POST INDIVIDUEL):', notificationId)
            console.log('üö® DEBUG: NOTIFICATION ENVOY√âE (POST INDIVIDUEL)')
            
            // Ouvrir la modale m√™me en cas d'erreur pour afficher les d√©tails
            setWebhookResponse({
                error: true,
                message: errorMessage,
                details: error instanceof Error ? error.stack : error,
                postId: post.id
            })
            setShowWebhookModal(true)
        } finally {
            setSendingSinglePost(null)
        }
    }, [getCsrfToken])

    // Fonction de test pour forcer une erreur (DEBUG)
    const testErrorNotification = useCallback(() => {
        console.log('üß™ TEST: D√©clenchement d\'une notification d\'erreur de test')
        notifications.show({
            title: 'Test d\'erreur',
            message: 'Ceci est une notification d\'erreur de test pour v√©rifier le syst√®me de notifications',
            color: 'red',
            autoClose: 5000,
        })
    }, [])

    const closeWebhookModal = useCallback(() => {
        setShowWebhookModal(false)
        setWebhookResponse(null)
    }, [])

    return {
        sendingToN8n,
        sendingSinglePost,
        webhookResponse,
        showWebhookModal,
        sendPostsToN8n,
        sendSinglePostToN8n,
        closeWebhookModal,
        testErrorNotification, // DEBUG - fonction de test
    }
}
